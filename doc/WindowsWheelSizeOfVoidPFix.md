# Windows Wheel SIZEOF_VOID_P Fix

## Issue Summary

Windows AMD64 wheel builds were failing with a Cython compile-time assertion error related to `SIZEOF_VOID_P`. This document describes the issue, root cause, and the implemented solution.

## The Problem

### Symptom

Windows wheel builds failed during C compilation with an error like:

```c
error: enumerator value for '__pyx_check_sizeof_voidp' is not an integer constant
enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
```

This assertion is generated by Cython to ensure that the pointer size it calculated during code generation matches the pointer size at C compilation time.

### When It Fails

The assertion causes a **division by zero** error when:
- `SIZEOF_VOID_P` (set by Cython) != `sizeof(void*)` (calculated by C compiler)
- This results in: `1 / (int)(8 == 4)` → `1 / 0` → compile error

## Root Cause

Cython generates C code with `#define SIZEOF_VOID_P` based on the Python interpreter's pointer size:
- On 64-bit Python: `SIZEOF_VOID_P = 8`
- On 32-bit Python: `SIZEOF_VOID_P = 4`

However, the C compiler calculates `sizeof(void*)` at compile time based on:
- Architecture flags (`-m32`, `-m64`)
- Default compiler settings
- Target platform configuration

**On Windows**, if the GCC compiler is not explicitly told the target architecture, it may default to a different pointer size than Cython expects, causing the assertion to fail.

## Previous Attempts (That Failed)

From `doc/WindowsWheelBuildAttempts_Post_c788f5a.md`:

1. **Attempt #1**: Force Cython regeneration with `force=True`
   - Result: ❌ Failed - SIZEOF_VOID_P still mismatched

2. **Attempt #2**: Explicitly set SIZEOF_VOID_P via `compile_time_env`
   - Result: ❌ Failed - issue persisted

These attempts failed because they tried to fix the Cython side, but the real issue was that the C compiler needed explicit architecture information.

## The Solution

### Two-Pronged Approach

The fix addresses both the C compiler and Cython configuration on Windows:

#### 1. C Compiler Architecture Flag (setup.py lines 125-138)

```python
# Platform-specific compile args
extra_compile_args = ['-std=c99', '-O3']
if platform.system() == 'Windows':
    # On Windows AMD64, explicitly set architecture to ensure SIZEOF_VOID_P matches
    # This fixes Cython's compile-time assertion: enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) }
    import struct
    pointer_size = struct.calcsize('P')
    if pointer_size == 8:
        # 64-bit
        extra_compile_args.append('-m64')
    elif pointer_size == 4:
        # 32-bit
        extra_compile_args.append('-m32')
    print(f"Windows build: Adding -m{pointer_size*8} flag to match pointer size {pointer_size} bytes")
```

**How it works**:
- Detect Python's pointer size using `struct.calcsize('P')`
- Add `-m64` for 64-bit or `-m32` for 32-bit to `extra_compile_args`
- This explicitly tells GCC to compile for the correct architecture
- Now `sizeof(void*)` in C will match Cython's `SIZEOF_VOID_P`

#### 2. Windows-Specific Cython Configuration (setup.py lines 164-173)

```python
# Windows-specific Cython configuration to fix SIZEOF_VOID_P compile-time assertion
# The issue occurs when Cython generates C code with SIZEOF_VOID_P that doesn't match
# the target platform's sizeof(void*) during C compilation on Windows
if platform.system() == 'Windows':
    compiler_directives['preliminary_late_includes_cy28'] = True
    # Use build_dir to ensure clean builds on Windows
    cythonize_kwargs = {
        'include_path': ['src'],
        'compiler_directives': compiler_directives,
        'nthreads': 0,  # Force single-threaded to avoid race conditions
        'build_dir': 'build',
        'force': True,  # Force regeneration on Windows
    }
else:
    cythonize_kwargs = {
        'include_path': ['src'],
        'compiler_directives': compiler_directives,
    }
```

**How it works**:
- `preliminary_late_includes_cy28=True`: Ensures proper include file ordering
- `force=True`: Forces C code regeneration on Windows to ensure fresh builds
- `nthreads=0`: Prevents race conditions during parallel compilation
- `build_dir='build'`: Ensures clean build directory structure

## Why This Works

The key insight is that **the SIZEOF_VOID_P assertion is correct** - it's designed to catch exactly this kind of mismatch. The fix ensures that:

1. **Cython knows the pointer size**: It correctly detects it from the Python interpreter
2. **GCC knows the pointer size**: We explicitly tell it via `-m64` or `-m32`
3. **Both match**: The assertion passes because 8 == 8 (or 4 == 4)

Without the `-m64` flag, GCC might:
- Use its default architecture (could be 32-bit)
- Get confused by mixed environments
- Default to the wrong pointer size

## Platform Specificity

### Why Windows Only?

This fix is **Windows-specific** because:

1. **Linux**: GCC typically has correct defaults from the system configuration
2. **macOS**: Clang/GCC are properly configured by Xcode/Homebrew
3. **Windows**: MinGW GCC needs explicit architecture flags

The fix **does not affect** Linux or macOS builds - they continue to use the standard configuration.

## Testing and Verification

### Build Output

On Windows, you should see:
```
Windows build with CFLAGS=..., LDFLAGS=...
Windows GLPK paths: includes=[...], libs=[...]
Windows build: Adding -m64 flag to match pointer size 8 bytes
```

### Compilation

The C compilation should succeed with:
```
gcc.exe -m64 -std=c99 -O3 ... -c src/benpy.c
```

Note the `-m64` flag is present.

### Verification

The assertion will pass silently:
```c
enum { __pyx_check_sizeof_voidp = 1 / (int)(SIZEOF_VOID_P == sizeof(void*)) };
// Expands to: enum { __pyx_check_sizeof_voidp = 1 / (int)(8 == 8) };
// Which is: enum { __pyx_check_sizeof_voidp = 1 };
// ✓ Valid!
```

## Implementation Details

### Files Modified

- `setup.py`: Added Windows-specific compile flags and Cython configuration

### Files Not Modified

- `src/benpy.pyx`: No changes to source code
- `src/pxd/*.pxd`: No changes to Cython declarations
- `pyproject.toml`: No changes to build system requirements

### Backwards Compatibility

- ✅ No changes to Linux builds
- ✅ No changes to macOS builds
- ✅ No changes to API or functionality
- ✅ No new dependencies
- ✅ Compatible with Cython >=3.0.0 (as already required)

## Related Issues

### Cython 3.0 Changes

Cython 3.0 introduced stricter compile-time checks, including the SIZEOF_VOID_P assertion. This is a **feature, not a bug** - it catches real cross-compilation issues.

### MinGW vs MSVC

This project uses **MinGW GCC** (not MSVC) on Windows because:
- GLPK is available via MSYS2
- Bensolve C code uses GCC-specific features (`-std=c99`)
- Cross-platform consistency (GCC everywhere)

## Troubleshooting

If the fix doesn't work:

1. **Check GCC is used**: Look for `gcc.exe` in build output, not `cl.exe` (MSVC)
2. **Check -m64 flag**: Should appear in compile command
3. **Check Python arch**: Run `python -c "import struct; print(struct.calcsize('P'))"` should print `8`
4. **Check environment**: Ensure `CC=gcc` and `CXX=g++` are set

## References

- Previous attempts: `doc/WindowsWheelBuildAttempts_Post_c788f5a.md`
- Cython documentation: https://cython.readthedocs.io/en/latest/
- GCC -m32/-m64 flags: https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html
- Cython SIZEOF_VOID_P: https://github.com/cython/cython/issues/4452

## Conclusion

This fix resolves the Windows wheel SIZEOF_VOID_P issue by:
1. Explicitly telling GCC the target architecture via `-m64` or `-m32`
2. Configuring Cython for optimal Windows builds
3. Maintaining backwards compatibility with other platforms

The fix is **surgical** - it only affects Windows builds and doesn't change source code or functionality.
