
==================================================================================
Bensolve Header Diff Report
==================================================================================

Generated on: Wed Nov  5 00:47:20 UTC 2025
Comparing: bensolve-mod vs bensolve-2.1.0

This report analyzes API changes between the current vendored version
(bensolve-mod) and the official bensolve 2.1.0 release.


==================================================================================
Summary of Header Files
==================================================================================

Header files analyzed:
  - bslv_main.h
  - bslv_lp.h
  - bslv_vlp.h
  - bslv_algs.h
  - bslv_lists.h
  - bslv_poly.h


==================================================================================
Detailed Diff Analysis
==================================================================================


--------------------------------------------------------------------------------
FILE: bslv_main.h
--------------------------------------------------------------------------------

✗ Changes detected

--- Full Unified Diff ---

--- /home/runner/work/benpy/benpy/src/bensolve-mod/bslv_main.h	2025-11-05 00:43:36.814382423 +0000
+++ /home/runner/work/benpy/benpy/src/bensolve-2.1.0/bslv_main.h	2025-11-05 00:43:36.777382297 +0000
@@ -1,7 +1,7 @@
 /*
 This file is part of BENSOLVE - VLP solver
 
-Copyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing
+Copyright (C) 2014-2017 Andreas Löhne and Benjamin Weißing
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -21,13 +21,16 @@
 #ifndef BSLV_MAIN_H
 #define BSLV_MAIN_H
 
+
 typedef int lp_idx;
 
 #define ABS(x) (((x) < 0 ? -(x) : (x)))
 #define MAX(x,y) (((x) < (y) ? (y) : (x)))
 
-#define THISVERSION "version 2.0.1"
-#define WELCOME "BENSOLVE: VLP Solver, %s\nCopyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing\nThis is free software; see the source code for copying conditions.\nThere is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n"
+#define THISVERSION "2.1.0"
+#define WELCOME "BENSOLVE: VLP Solver, %s\nCopyright (C) 2014-2017 Andreas L%shne and Benjamin Wei%sing\nThis is free software; see the source code for copying conditions.\nThere is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n"
+    #define UMLAUT_OE "ö"
+    #define UMLAUT_SZ "ß"
 #define USAGE "\nUsage: bensolve file [options]\n\n"
 
 #ifndef POLY_TEST
@@ -103,7 +106,7 @@
 enum _phase_type {PHASE0, PHASE1_PRIMAL, PHASE1_DUAL, PHASE2_PRIMAL, PHASE2_DUAL};
 enum _format_type {FORMAT_SHORT, FORMAT_LONG, FORMAT_AUTO};
 enum _lp_status_type {LP_INFEASIBLE, LP_UNBOUNDED, LP_UNEXPECTED_STATUS, LP_UNDEFINED_STATUS, LP_OPTIMAL};
-enum _sol_status_type {VLP_NOSTATUS, VLP_INFEASIBLE, VLP_UNBOUNDED, VLP_NOVERTEX, VLP_OPTIMAL, VLP_INPUTERROR};
+enum _sol_status_type {VLP_NOSTATUS, VLP_INFEASIBLE, VLP_UNBOUNDED, VLP_NOVERTEX, VLP_OPTIMAL, VLP_INPUTERROR, VLP_UNEXPECTED_STATUS};
 enum _cone_gen_type {CONE, DUALCONE, DEFAULT};
 enum _c_dir_type{C_DIR_POS, C_DIR_NEG};
 enum _swap_type{SWAP, NO_SWAP};

--- Analysis by Category ---

VERSION STRINGS:
  bensolve-mod:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
#define THISVERSION "version 2.0.1"
  bensolve-2.1.0:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
#define THISVERSION "2.1.0"

TYPEDEFS:
  bensolve-mod:
    typedef int lp_idx;
    typedef enum _alg_type alg_type;
    typedef enum _lp_method_type lp_method_type;
    typedef enum _lp_hom_type lp_hom_type;
    typedef enum _cone_out_type cone_out_type;
    typedef enum _phase_type phase_type;
    typedef enum _format_type format_type;
    typedef enum _lp_status_type lp_status_type;
    typedef enum _sol_status_type sol_status_type;
    typedef enum _cone_gen_type cone_gen_type;
    typedef enum _c_dir_type c_dir_type;
    typedef enum _swap_type swap_type;
    typedef enum _pre_img_type pre_img_type;
  bensolve-2.1.0:
    typedef int lp_idx;
    typedef enum _alg_type alg_type;
    typedef enum _lp_method_type lp_method_type;
    typedef enum _lp_hom_type lp_hom_type;
    typedef enum _cone_out_type cone_out_type;
    typedef enum _phase_type phase_type;
    typedef enum _format_type format_type;
    typedef enum _lp_status_type lp_status_type;
    typedef enum _sol_status_type sol_status_type;
    typedef enum _cone_gen_type cone_gen_type;
    typedef enum _c_dir_type c_dir_type;
    typedef enum _swap_type swap_type;
    typedef enum _pre_img_type pre_img_type;

DEFINES (sample):
  bensolve-mod (count: 41):
    #define BSLV_MAIN_H
    #define ABS(x) (((x) < 0 ? -(x) : (x)))
    #define MAX(x,y) (((x) < (y) ? (y) : (x)))
    #define THISVERSION "version 2.0.1"
    #define WELCOME "BENSOLVE: VLP Solver, %s\nCopyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing\nThis is free software; see the source code for copying conditions.\nThere is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n"
    #define USAGE "\nUsage: bensolve file [options]\n\n"
    #define POLY_TEST 0
    #define EPS_C 1e-7
    #define EPS_POLY 1e-9
    #define EPS_OUTPUT_CHOP 1e-10
  bensolve-2.1.0 (count: 41):
    #define BSLV_MAIN_H
    #define ABS(x) (((x) < 0 ? -(x) : (x)))
    #define MAX(x,y) (((x) < (y) ? (y) : (x)))
    #define THISVERSION "2.1.0"
    #define WELCOME "BENSOLVE: VLP Solver, %s\nCopyright (C) 2014-2017 Andreas L%shne and Benjamin Wei%sing\nThis is free software; see the source code for copying conditions.\nThere is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\nFITNESS FOR A PARTICULAR PURPOSE.\n"
    #define USAGE "\nUsage: bensolve file [options]\n\n"
    #define POLY_TEST 0
    #define EPS_C 1e-7
    #define EPS_POLY 1e-9
    #define EPS_OUTPUT_CHOP 1e-10

FUNCTION DECLARATIONS:
  bensolve-mod:
  bensolve-2.1.0:

ENUMS:
  bensolve-mod:
    typedef enum _alg_type alg_type;
    typedef enum _lp_method_type lp_method_type;
    typedef enum _lp_hom_type lp_hom_type;
    typedef enum _cone_out_type cone_out_type;
    typedef enum _phase_type phase_type;
    typedef enum _format_type format_type;
    typedef enum _lp_status_type lp_status_type;
    typedef enum _sol_status_type sol_status_type;
    typedef enum _cone_gen_type cone_gen_type;
    typedef enum _c_dir_type c_dir_type;
    typedef enum _swap_type swap_type;
    typedef enum _pre_img_type pre_img_type;
    
    #endif
  bensolve-2.1.0:
    typedef enum _alg_type alg_type;
    typedef enum _lp_method_type lp_method_type;
    typedef enum _lp_hom_type lp_hom_type;
    typedef enum _cone_out_type cone_out_type;
    typedef enum _phase_type phase_type;
    typedef enum _format_type format_type;
    typedef enum _lp_status_type lp_status_type;
    typedef enum _sol_status_type sol_status_type;
    typedef enum _cone_gen_type cone_gen_type;
    typedef enum _c_dir_type c_dir_type;
    typedef enum _swap_type swap_type;
    typedef enum _pre_img_type pre_img_type;
    
    #endif

STRUCTS:
  (none found in either version)


--------------------------------------------------------------------------------
FILE: bslv_lp.h
--------------------------------------------------------------------------------

✗ Changes detected

--- Full Unified Diff ---

--- /home/runner/work/benpy/benpy/src/bensolve-mod/bslv_lp.h	2025-11-05 00:43:36.814382423 +0000
+++ /home/runner/work/benpy/benpy/src/bensolve-2.1.0/bslv_lp.h	2025-11-05 00:43:36.777382297 +0000
@@ -1,8 +1,7 @@
 /*
 This file is part of BENSOLVE - VLP solver
 
-Copyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing
-Copyright (C) 2017 Marko Budinich
+Copyright (C) 2014-2017 Andreas Löhne and Benjamin Weißing
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -22,41 +21,16 @@
 #ifndef BSLV_LP_H
 #define BSLV_LP_H
 
-#include <glpk.h>
 #include "bslv_main.h"
 #include "bslv_lists.h"
 #include "bslv_vlp.h"
 
-typedef struct { ;
-    double lp_time;
-    int lp_num;
-    glp_prob *lp;
-
-// for inhomogeneous problem
-    int type[18];
-// for homogeneous problem: change "double bounded" to "fixed"
-    int type_hom[18];
-    /*
-    type('d'-'d')==GLP_DB
-    type('f'-'d')==GLP_FR
-    type('l'-'d')==GLP_LO
-    type('s'-'d')==GLP_FX
-    type('u'-'d')==GLP_UP
-    */
-
-    lp_idx extra_rows;
-    lp_idx extra_cols;
-    glp_smcp parm;
-
-} lptype;
-
-
-//void lp_init_struct(lptype *lpstr);
-void lp_write (lptype *lpstr);
-double lp_write_sol(lptype *lpstr);
+void lp_write (size_t i);
+
+double lp_write_sol(size_t i);
 
 // initialize lp
-void lp_init(const vlptype *vlp, lptype *lpstr);
+void lp_init(const vlptype *vlp);
 
 /*
  - for nonapprearing coefficients in obj and A, zero is assumed
@@ -70,56 +44,56 @@
 */
 
 // set lp options
-void lp_set_options(const opttype *opt, phase_type phase, lptype *lpstr);
+void lp_set_options(const opttype *opt, phase_type phase);
 
 // create a copy lp[dest]] of lp[src]
-void lp_copy(size_t dest, size_t src, lptype *lpstr);
+void lp_copy(size_t dest, size_t src);
 
 // delete extra rows and set num new extra rows
-void lp_update_extra_coeffs (lp_idx n_rows, lp_idx n_cols, lptype *lpstr);
+void lp_update_extra_coeffs (lp_idx n_rows, lp_idx n_cols);
 
 // set (replace) row bounds
-void lp_set_rows (boundlist const *rows, lptype *lpstr);
+void lp_set_rows (size_t i, boundlist const *rows);
 
 // set (replace) row bounds of homogeneous problem
-void lp_set_rows_hom (boundlist const *rows, lptype *lpstr);
+void lp_set_rows_hom (size_t i, boundlist const *rows);
 
 // set (replace) column bounds
-void lp_set_cols (boundlist const *cols, lptype *lpstr);
+void lp_set_cols (size_t i, boundlist const *cols);
 
 // set (replace) column bounds of homogeneous problem
-void lp_set_cols_hom (boundlist const *cols, lptype *lpstr);
+void lp_set_cols_hom (size_t i, boundlist const *cols);
 
 // set (replace) constraint coefficients
-int lp_set_mat (list2d const *A, lptype *lpstr);
+int lp_set_mat (size_t i, list2d const *A);
 
 // set (replace) constraint coefficients row
-void lp_set_mat_row (list1d *list, lp_idx ridx, lptype *lpstr);
+void lp_set_mat_row (size_t i, list1d *list, lp_idx ridx);
 
 // set all objective coefficients to zero
-void lp_clear_obj_coeffs (lptype *lpstr);
+void lp_clear_obj_coeffs (size_t i);
 
 // set (replace) (a subset of) objective coefficients
-void lp_set_obj_coeffs (list1d const *list, lptype *lpstr);
+void lp_set_obj_coeffs (size_t i, list1d const *list);
 
 // solve problem, return
-lp_status_type lp_solve(lptype *lpstr);
+lp_status_type lp_solve(size_t i);
 
 // retrieve solutions, x and v need to be allocated before functions are called */
-void lp_primal_solution_rows(double *const x, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
-void lp_primal_solution_cols(double *const x, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
-void lp_dual_solution_rows(double *const u, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
-void lp_dual_solution_cols(double *const u, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
+void lp_primal_solution_rows(size_t i, double *const x, lp_idx firstidx, lp_idx size, double sign);
+void lp_primal_solution_cols(size_t i, double *const x, lp_idx firstidx, lp_idx size, double sign);
+void lp_dual_solution_rows(size_t i, double *const u, lp_idx firstidx, lp_idx size, double sign);
+void lp_dual_solution_cols(size_t i, double *const u, lp_idx firstidx, lp_idx size, double sign);
 
 // return (optimal) objective value
-double lp_obj_val(lptype *lpstr);
+double lp_obj_val(size_t i);
 
 // return CPU time of lp solver in seconds
-double lp_get_time (lptype *lpstr);
+double lp_get_time (size_t i);
 
 // return number of LPs (type i) solved
-int lp_get_num (lptype *lpstr);
+int lp_get_num (size_t i);
 
-void lp_free(lptype *lpstr);
+void lp_free(size_t i);
 
 #endif

--- Analysis by Category ---

VERSION STRINGS:
  bensolve-mod:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
  bensolve-2.1.0:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

TYPEDEFS:
  bensolve-mod:
    typedef struct { ;
  bensolve-2.1.0:

DEFINES (sample):
  bensolve-mod (count: 1):
    #define BSLV_LP_H
  bensolve-2.1.0 (count: 1):
    #define BSLV_LP_H

FUNCTION DECLARATIONS:
  bensolve-mod:
    void lp_write (lptype *lpstr);
    double lp_write_sol(lptype *lpstr);
    void lp_init(const vlptype *vlp, lptype *lpstr);
    void lp_set_options(const opttype *opt, phase_type phase, lptype *lpstr);
    void lp_copy(size_t dest, size_t src, lptype *lpstr);
    void lp_update_extra_coeffs (lp_idx n_rows, lp_idx n_cols, lptype *lpstr);
    void lp_set_rows (boundlist const *rows, lptype *lpstr);
    void lp_set_rows_hom (boundlist const *rows, lptype *lpstr);
    void lp_set_cols (boundlist const *cols, lptype *lpstr);
    void lp_set_cols_hom (boundlist const *cols, lptype *lpstr);
    int lp_set_mat (list2d const *A, lptype *lpstr);
    void lp_set_mat_row (list1d *list, lp_idx ridx, lptype *lpstr);
    void lp_clear_obj_coeffs (lptype *lpstr);
    void lp_set_obj_coeffs (list1d const *list, lptype *lpstr);
    lp_status_type lp_solve(lptype *lpstr);
    void lp_primal_solution_rows(double *const x, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
    void lp_primal_solution_cols(double *const x, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
    void lp_dual_solution_rows(double *const u, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
    void lp_dual_solution_cols(double *const u, lp_idx firstidx, lp_idx size, double sign, lptype *lpstr);
    double lp_obj_val(lptype *lpstr);
    double lp_get_time (lptype *lpstr);
    int lp_get_num (lptype *lpstr);
    void lp_free(lptype *lpstr);
  bensolve-2.1.0:
    void lp_write (size_t i);
    double lp_write_sol(size_t i);
    void lp_init(const vlptype *vlp);
    void lp_set_options(const opttype *opt, phase_type phase);
    void lp_copy(size_t dest, size_t src);
    void lp_update_extra_coeffs (lp_idx n_rows, lp_idx n_cols);
    void lp_set_rows (size_t i, boundlist const *rows);
    void lp_set_rows_hom (size_t i, boundlist const *rows);
    void lp_set_cols (size_t i, boundlist const *cols);
    void lp_set_cols_hom (size_t i, boundlist const *cols);
    int lp_set_mat (size_t i, list2d const *A);
    void lp_set_mat_row (size_t i, list1d *list, lp_idx ridx);
    void lp_clear_obj_coeffs (size_t i);
    void lp_set_obj_coeffs (size_t i, list1d const *list);
    lp_status_type lp_solve(size_t i);
    void lp_primal_solution_rows(size_t i, double *const x, lp_idx firstidx, lp_idx size, double sign);
    void lp_primal_solution_cols(size_t i, double *const x, lp_idx firstidx, lp_idx size, double sign);
    void lp_dual_solution_rows(size_t i, double *const u, lp_idx firstidx, lp_idx size, double sign);
    void lp_dual_solution_cols(size_t i, double *const u, lp_idx firstidx, lp_idx size, double sign);
    double lp_obj_val(size_t i);
    double lp_get_time (size_t i);
    int lp_get_num (size_t i);
    void lp_free(size_t i);

ENUMS:
  (none found in either version)

STRUCTS:
  bensolve-mod:
    typedef struct { ;
        double lp_time;
        int lp_num;
        glp_prob *lp;
    
    // for inhomogeneous problem
        int type[18];
    // for homogeneous problem: change "double bounded" to "fixed"
        int type_hom[18];
        /*
        type('d'-'d')==GLP_DB
        type('f'-'d')==GLP_FR
        type('l'-'d')==GLP_LO
        type('s'-'d')==GLP_FX
        type('u'-'d')==GLP_UP
        */
    
        lp_idx extra_rows;
        lp_idx extra_cols;
        glp_smcp parm;
    
    } lptype;
  bensolve-2.1.0:
    


--------------------------------------------------------------------------------
FILE: bslv_vlp.h
--------------------------------------------------------------------------------

✗ Changes detected

--- Full Unified Diff ---

--- /home/runner/work/benpy/benpy/src/bensolve-mod/bslv_vlp.h	2025-11-05 00:43:36.814382423 +0000
+++ /home/runner/work/benpy/benpy/src/bensolve-2.1.0/bslv_vlp.h	2025-11-05 00:43:36.777382297 +0000
@@ -1,8 +1,7 @@
 /*
 This file is part of BENSOLVE - VLP solver
 
-Copyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing
-Copyright (C) 2017 Marko Budinich
+Copyright (C) 2014-2017 Andreas Löhne and Benjamin Weißing
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -23,10 +22,13 @@
 #define BSLV_VLP_H
 
 #include <setjmp.h> // longjmp, setjmp
+#include <getopt.h>
 
 #include "bslv_main.h"
 #include "bslv_lists.h" 
 
+
+
 #define PROBLEM_DESIGNATOR "vlp"
 #define STOP_AT_WARNING 0	// set 1 to compile with stop at warning
 
@@ -87,9 +89,7 @@
 
 typedef struct 
 {
-    int printfiles;							// 1 to write files
-	int logfile;							// 1 to write logfile
-	int bounded;							//
+	int bounded;
 	int plot;
 	char filename[255+1];
 	pre_img_type solution;					// PRE_IMG_OFF - PRE_IMG_ON
@@ -107,14 +107,18 @@
 	double eps_benson_phase2;				// Epsilon of Benson algorithm in Phase 2
 } opttype;
 
-int vlp_init(csatype *csa, vlptype *vlp, const opttype *opt);
+
+int vlp_init(char const *filename, vlptype *vlp, const opttype *opt);
+
+
+int set_opt(opttype* opt, const int argc, char **argv);
+int write_log_file(vlptype * vlp, soltype *sol, opttype *opt, double elapsedTime, int lp_num);
+void display_info(opttype *opt, double elapsedTime, int lp_num);
+
 void vlp_free(vlptype *vlp);
 
-void sol_init(soltype *sol, const vlptype *vlp, const opttype *opt);
+int sol_init(soltype *sol, const vlptype *vlp, const opttype *opt);
 void sol_free(soltype *sol);
 
 void set_default_opt(opttype *opt);
-//int vlp_init(char const *filename, vlptype *vlp, const opttype *opt);
-void set_input(csatype *csa, char const *filename);
-
 #endif

--- Analysis by Category ---

VERSION STRINGS:
  bensolve-mod:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
  bensolve-2.1.0:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

TYPEDEFS:
  bensolve-mod:
    typedef struct
    typedef struct 
    typedef struct 
    typedef struct 
  bensolve-2.1.0:
    typedef struct
    typedef struct 
    typedef struct 
    typedef struct 

DEFINES (sample):
  bensolve-mod (count: 3):
    #define BSLV_VLP_H
    #define PROBLEM_DESIGNATOR "vlp"
    #define STOP_AT_WARNING 0	// set 1 to compile with stop at warning
  bensolve-2.1.0 (count: 3):
    #define BSLV_VLP_H
    #define PROBLEM_DESIGNATOR "vlp"
    #define STOP_AT_WARNING 0	// set 1 to compile with stop at warning

FUNCTION DECLARATIONS:
  bensolve-mod:
    int vlp_init(csatype *csa, vlptype *vlp, const opttype *opt);
    void vlp_free(vlptype *vlp);
    void sol_init(soltype *sol, const vlptype *vlp, const opttype *opt);
    void sol_free(soltype *sol);
    void set_default_opt(opttype *opt);
    void set_input(csatype *csa, char const *filename);
  bensolve-2.1.0:
    int vlp_init(char const *filename, vlptype *vlp, const opttype *opt);
    int set_opt(opttype* opt, const int argc, char **argv);
    int write_log_file(vlptype * vlp, soltype *sol, opttype *opt, double elapsedTime, int lp_num);
    void display_info(opttype *opt, double elapsedTime, int lp_num);
    void vlp_free(vlptype *vlp);
    int sol_init(soltype *sol, const vlptype *vlp, const opttype *opt);
    void sol_free(soltype *sol);
    void set_default_opt(opttype *opt);

ENUMS:
  (none found in either version)

STRUCTS:
  bensolve-mod:
    typedef struct
    {
    	jmp_buf jump;		// label for go to in case of error
    	const char *fname;	// name of input text file
    	FILE *fp;			// stream assigned to input text file */
    	int count;			// line count
    	int c;				// current character
    	char field[255+1];	// data field
    	int empty;			// warning 'empty line ignored' was printed
    	int nonint;			// warning 'non-integer data detected' was printed
    	char msg[255+1];	// error and warning messages
    	int error;			// error flag
    	int warning;		// warning flag
    } csatype; 
    typedef struct 
    {
    	list2d *A_ext;					// non-zero constraint and objective coefficients: A_ext = (A,0;P -I)
    	boundlist *rows;				// non-standard row bounds (standard is 'f')
    	boundlist *cols;				// non-standard column bounds (standard is 's')
    	int optdir;						// 1 for minimization, -1 for maximization
    	cone_gen_type cone_gen;			// type of ordering cone generators CONE: CONE | DUALCONE | DEFAULT
    	double *gen;					// generators of ordering cone (primal or dual)
    	double *c;						// duality parameter vector (given data, unscaled)
    	long int nz;					// number of non-zero entries of A
    	long int nzobj;					// number of non-zero entries of P
    	lp_idx n;						// number of variables (cols)
    	lp_idx m;						// number of constraints (rows)
    	lp_idx q;						// number of objectives
    	lp_idx n_gen;					// number of generators of ordering cone (primal or dual)
    } vlptype;
    typedef struct 
    {
    	lp_idx m;						// number of rows (constraints)
    	lp_idx n;						// number of cols (varibles)
    	lp_idx q;						// number of objectives
    	lp_idx o;						// number of generators of ordering cone (after vertex enumeration and scaling)
    	lp_idx p;						// number of generators of dual of ordering cone (after vertex enumeration and scaling)
    	lp_idx r;						// number of generators of dual cone of recession cone of upper image
    	lp_idx h;						// number of generators of recession cone of upper image
    	double *eta;					// result of phase0
    	double *Y;						// generators of ordering cone as columns of Y (non-redundant and scaled columns)
    	double *Z;						// generators of dual cone of C as columns in matrix Z (non-redundant and scaled columns that that Z' * c == (1,...,1)')
    	double *c;						// geometric duality parameter vector (scaled such that c_q=1)
    	double *R;						// result of phase1: columns are generators of dual cone of recession cone of upper image
    	double *H;						// result of phase1: columns are generators of recession cone of upper image
    	sol_status_type status;			// solution status of VLP
    	c_dir_type c_dir;				// type of duality parameter vector
    	size_t pp;						// number of vertices of upper image
    	size_t dd;						// number of vertices of lower image
    	size_t pp_dir;					// number of extreme directions of upper image
    	size_t dd_dir;					// number of extreme directions of lower image
    } soltype;
    typedef struct 
    {
        int printfiles;							// 1 to write files
    	int logfile;							// 1 to write logfile
    	int bounded;							//
    	int plot;
    	char filename[255+1];
    	pre_img_type solution;					// PRE_IMG_OFF - PRE_IMG_ON
    	format_type format;						// SHORT - LONG - AUTO
    	lp_method_type lp_method_phase0;		// PRIMAL_SIMPLEX - DUAL_SIMPLEX - DUAL_PRIMAL_SIMPLEX
    	lp_method_type lp_method_phase1;		// PRIMAL_SIMPLEX - DUAL_SIMPLEX - DUAL_PRIMAL_SIMPLEX - AUTO
    	lp_method_type lp_method_phase2;		// PRIMAL_SIMPLEX - DUAL_SIMPLEX - DUAL_PRIMAL_SIMPLEX - AUTO
    	int message_level;						// 0 - 1 - 2 - 3
    	int lp_message_level;					// 0 - 1 - 2 - 3
    	alg_type alg_phase1;					// PRIMAL - DUAL
    	alg_type alg_phase2;					// PRIMAL - DUAL
    	double eps_phase0;						// Epsilon used in Phase 0
    	double eps_phase1;						// Epsilon used in Phase 1
    	double eps_benson_phase1;				// Epsilon of Benson algorithm in Phase 1
    	double eps_benson_phase2;				// Epsilon of Benson algorithm in Phase 2
    } opttype;
  bensolve-2.1.0:
    typedef struct
    {
    	jmp_buf jump;		// label for go to in case of error
    	const char *fname;	// name of input text file
    	FILE *fp;			// stream assigned to input text file */
    	int count;			// line count
    	int c;				// current character
    	char field[255+1];	// data field
    	int empty;			// warning 'empty line ignored' was printed
    	int nonint;			// warning 'non-integer data detected' was printed
    	char msg[255+1];	// error and warning messages
    	int error;			// error flag
    	int warning;		// warning flag
    } csatype; 
    typedef struct 
    {
    	list2d *A_ext;					// non-zero constraint and objective coefficients: A_ext = (A,0;P -I)
    	boundlist *rows;				// non-standard row bounds (standard is 'f')
    	boundlist *cols;				// non-standard column bounds (standard is 's')
    	int optdir;						// 1 for minimization, -1 for maximization
    	cone_gen_type cone_gen;			// type of ordering cone generators CONE: CONE | DUALCONE | DEFAULT
    	double *gen;					// generators of ordering cone (primal or dual)
    	double *c;						// duality parameter vector (given data, unscaled)
    	long int nz;					// number of non-zero entries of A
    	long int nzobj;					// number of non-zero entries of P
    	lp_idx n;						// number of variables (cols)
    	lp_idx m;						// number of constraints (rows)
    	lp_idx q;						// number of objectives
    	lp_idx n_gen;					// number of generators of ordering cone (primal or dual)
    } vlptype;
    typedef struct 
    {
    	lp_idx m;						// number of rows (constraints)
    	lp_idx n;						// number of cols (varibles)
    	lp_idx q;						// number of objectives
    	lp_idx o;						// number of generators of ordering cone (after vertex enumeration and scaling)
    	lp_idx p;						// number of generators of dual of ordering cone (after vertex enumeration and scaling)
    	lp_idx r;						// number of generators of dual cone of recession cone of upper image
    	lp_idx h;						// number of generators of recession cone of upper image
    	double *eta;					// result of phase0
    	double *Y;						// generators of ordering cone as columns of Y (non-redundant and scaled columns)
    	double *Z;						// generators of dual cone of C as columns in matrix Z (non-redundant and scaled columns that that Z' * c == (1,...,1)')
    	double *c;						// geometric duality parameter vector (scaled such that c_q=1)
    	double *R;						// result of phase1: columns are generators of dual cone of recession cone of upper image
    	double *H;						// result of phase1: columns are generators of recession cone of upper image
    	sol_status_type status;			// solution status of VLP
    	c_dir_type c_dir;				// type of duality parameter vector
    	size_t pp;						// number of vertices of upper image
    	size_t dd;						// number of vertices of lower image
    	size_t pp_dir;					// number of extreme directions of upper image
    	size_t dd_dir;					// number of extreme directions of lower image
    } soltype;
    typedef struct 
    {
    	int bounded;
    	int plot;
    	char filename[255+1];
    	pre_img_type solution;					// PRE_IMG_OFF - PRE_IMG_ON
    	format_type format;						// SHORT - LONG - AUTO
    	lp_method_type lp_method_phase0;		// PRIMAL_SIMPLEX - DUAL_SIMPLEX - DUAL_PRIMAL_SIMPLEX
    	lp_method_type lp_method_phase1;		// PRIMAL_SIMPLEX - DUAL_SIMPLEX - DUAL_PRIMAL_SIMPLEX - AUTO
    	lp_method_type lp_method_phase2;		// PRIMAL_SIMPLEX - DUAL_SIMPLEX - DUAL_PRIMAL_SIMPLEX - AUTO
    	int message_level;						// 0 - 1 - 2 - 3
    	int lp_message_level;					// 0 - 1 - 2 - 3
    	alg_type alg_phase1;					// PRIMAL - DUAL
    	alg_type alg_phase2;					// PRIMAL - DUAL
    	double eps_phase0;						// Epsilon used in Phase 0
    	double eps_phase1;						// Epsilon used in Phase 1
    	double eps_benson_phase1;				// Epsilon of Benson algorithm in Phase 1
    	double eps_benson_phase2;				// Epsilon of Benson algorithm in Phase 2
    } opttype;


--------------------------------------------------------------------------------
FILE: bslv_algs.h
--------------------------------------------------------------------------------

✗ Changes detected

--- Full Unified Diff ---

--- /home/runner/work/benpy/benpy/src/bensolve-mod/bslv_algs.h	2025-11-05 00:43:36.814382423 +0000
+++ /home/runner/work/benpy/benpy/src/bensolve-2.1.0/bslv_algs.h	2025-11-05 00:43:36.776382294 +0000
@@ -1,8 +1,7 @@
 /*
 This file is part of BENSOLVE - VLP solver
 
-Copyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing
-Copyright (C) 2017 Marko Budinich
+Copyright (C) 2014-2017 Andreas Löhne and Benjamin Weißing
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -23,15 +22,15 @@
 #define BSLV_ALGS_H
 
 #include "bslv_vlp.h"
-#include "bslv_lp.h"
 
 int cone_vertenum(double **prim, lp_idx *n_prim, double **dual, lp_idx *n_dual, double *prim_in, const size_t n_prim_in, const size_t dim, const opttype *opt, cone_out_type output, swap_type swap);
 
-void phase0(soltype *const sol, const vlptype *vlp, const opttype *opt,lptype *lpstr);
-void phase1_primal(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr);
-void phase2_primal(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr, poly_args *image);
-void phase1_dual(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr);
-void phase2_dual(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr, poly_args *image);
+int alg(soltype *const sol, const vlptype *vlp, const opttype *opt);
+void phase0(soltype *const sol, const vlptype *vlp, const opttype *opt);
+void phase1_primal(soltype *const sol, const vlptype *vlp, const opttype *opt);
+void phase2_primal(soltype *const sol, const vlptype *vlp, const opttype *opt);
+void phase1_dual(soltype *const sol, const vlptype *vlp, const opttype *opt);
+void phase2_dual(soltype *const sol, const vlptype *vlp, const opttype *opt);
 void phase2_init(soltype *sol, const vlptype *vlp);
 
 #endif

--- Analysis by Category ---

VERSION STRINGS:
  bensolve-mod:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
  bensolve-2.1.0:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

TYPEDEFS:
  bensolve-mod:
  bensolve-2.1.0:

DEFINES (sample):
  bensolve-mod (count: 1):
    #define BSLV_ALGS_H
  bensolve-2.1.0 (count: 1):
    #define BSLV_ALGS_H

FUNCTION DECLARATIONS:
  bensolve-mod:
    int cone_vertenum(double **prim, lp_idx *n_prim, double **dual, lp_idx *n_dual, double *prim_in, const size_t n_prim_in, const size_t dim, const opttype *opt, cone_out_type output, swap_type swap);
    void phase0(soltype *const sol, const vlptype *vlp, const opttype *opt,lptype *lpstr);
    void phase1_primal(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr);
    void phase2_primal(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr, poly_args *image);
    void phase1_dual(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr);
    void phase2_dual(soltype *const sol, const vlptype *vlp, const opttype *opt, lptype *lpstr, poly_args *image);
    void phase2_init(soltype *sol, const vlptype *vlp);
  bensolve-2.1.0:
    int cone_vertenum(double **prim, lp_idx *n_prim, double **dual, lp_idx *n_dual, double *prim_in, const size_t n_prim_in, const size_t dim, const opttype *opt, cone_out_type output, swap_type swap);
    int alg(soltype *const sol, const vlptype *vlp, const opttype *opt);
    void phase0(soltype *const sol, const vlptype *vlp, const opttype *opt);
    void phase1_primal(soltype *const sol, const vlptype *vlp, const opttype *opt);
    void phase2_primal(soltype *const sol, const vlptype *vlp, const opttype *opt);
    void phase1_dual(soltype *const sol, const vlptype *vlp, const opttype *opt);
    void phase2_dual(soltype *const sol, const vlptype *vlp, const opttype *opt);
    void phase2_init(soltype *sol, const vlptype *vlp);

ENUMS:
  (none found in either version)

STRUCTS:
  (none found in either version)


--------------------------------------------------------------------------------
FILE: bslv_lists.h
--------------------------------------------------------------------------------

✗ Changes detected

--- Full Unified Diff ---

--- /home/runner/work/benpy/benpy/src/bensolve-mod/bslv_lists.h	2025-11-05 00:43:36.814382423 +0000
+++ /home/runner/work/benpy/benpy/src/bensolve-2.1.0/bslv_lists.h	2025-11-05 00:43:36.776382294 +0000
@@ -1,7 +1,7 @@
 /*
 This file is part of BENSOLVE - VLP solver
 
-Copyright (C) 2014-2015 Andreas Löhne and Benjamin Weißing
+Copyright (C) 2014-2017 Andreas Löhne and Benjamin Weißing
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by

--- Analysis by Category ---

VERSION STRINGS:
  bensolve-mod:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
  bensolve-2.1.0:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

TYPEDEFS:
  bensolve-mod:
    typedef struct
    typedef struct
    typedef struct
  bensolve-2.1.0:
    typedef struct
    typedef struct
    typedef struct

DEFINES (sample):
  bensolve-mod (count: 1):
    #define BSLV_LISTS_H
  bensolve-2.1.0 (count: 1):
    #define BSLV_LISTS_H

FUNCTION DECLARATIONS:
  bensolve-mod:
    void string_fprint(const char *filename, const char *string);
    void matrix_fprint (double *mat_arr, int m, int n, int tda, char *filename, const char *format);
    void matrix_print (double *mat_arr, int m, int n, const char *format);
    int string_to_int(char *str, char *error_msg);
    int string_to_positive_int(char *str, char *error_msg);
    double string_to_positive_double(char *str, char *error_msg);
    void orthogonal_vector(double * mat_arr, int dim, int cidx);
    int is_equal(const lp_idx size, const double *vec1, const double *vec2, const double tol);
    int is_zero(const lp_idx size, const double *vec, const double tol);
    void list1d_init_idx(list1d *list, lp_idx firstidx);
    void list1d_free(list1d *list);
    void vector_to_list1d(list1d *const list, const double *vec_arr, int n);
    void list1d_print (list1d const *list, int size);
    void list2d_init_idx(list2d *list, lp_idx nrows, lp_idx ncols);
    void list2d_free(list2d *list);
    void list2d_print (list2d const *list);
    void boundlist_init_idx(boundlist *list, lp_idx firstidx);
    void boundlist_free(boundlist *list);
    void boundlist_print (boundlist const *list);
  bensolve-2.1.0:
    void string_fprint(const char *filename, const char *string);
    void matrix_fprint (double *mat_arr, int m, int n, int tda, char *filename, const char *format);
    void matrix_print (double *mat_arr, int m, int n, const char *format);
    int string_to_int(char *str, char *error_msg);
    int string_to_positive_int(char *str, char *error_msg);
    double string_to_positive_double(char *str, char *error_msg);
    void orthogonal_vector(double * mat_arr, int dim, int cidx);
    int is_equal(const lp_idx size, const double *vec1, const double *vec2, const double tol);
    int is_zero(const lp_idx size, const double *vec, const double tol);
    void list1d_init_idx(list1d *list, lp_idx firstidx);
    void list1d_free(list1d *list);
    void vector_to_list1d(list1d *const list, const double *vec_arr, int n);
    void list1d_print (list1d const *list, int size);
    void list2d_init_idx(list2d *list, lp_idx nrows, lp_idx ncols);
    void list2d_free(list2d *list);
    void list2d_print (list2d const *list);
    void boundlist_init_idx(boundlist *list, lp_idx firstidx);
    void boundlist_free(boundlist *list);
    void boundlist_print (boundlist const *list);

ENUMS:
  (none found in either version)

STRUCTS:
  bensolve-mod:
    typedef struct
    {
    	lp_idx size;	// number of entries
    	lp_idx *idx;	// vector of indices (smallest index is 1)
    	double *data;	// vector of coefficients
    } list1d;
    typedef struct
    {
    	size_t size;	// number of entries
    	lp_idx *idx1;	// vector of first (row) indices (smallest index is 1)
    	lp_idx *idx2;	// vector of second (column) indices (smallest index is 1)
    	double *data;	// vector of coefficients
    } list2d;
    typedef struct
    { 
    	lp_idx size;	// number of entries	
    	lp_idx *idx;	// vector of indices (smallest index is 1)
    	double *lb;		// vector of lower bound entries
    	double *ub;		// vector of upper bound entries
    	char *type;		// vector of GLPK types: 'f', 'l', 'u', 'd', 's'
    } boundlist;
  bensolve-2.1.0:
    typedef struct
    {
    	lp_idx size;	// number of entries
    	lp_idx *idx;	// vector of indices (smallest index is 1)
    	double *data;	// vector of coefficients
    } list1d;
    typedef struct
    {
    	size_t size;	// number of entries
    	lp_idx *idx1;	// vector of first (row) indices (smallest index is 1)
    	lp_idx *idx2;	// vector of second (column) indices (smallest index is 1)
    	double *data;	// vector of coefficients
    } list2d;
    typedef struct
    { 
    	lp_idx size;	// number of entries	
    	lp_idx *idx;	// vector of indices (smallest index is 1)
    	double *lb;		// vector of lower bound entries
    	double *ub;		// vector of upper bound entries
    	char *type;		// vector of GLPK types: 'f', 'l', 'u', 'd', 's'
    } boundlist;


--------------------------------------------------------------------------------
FILE: bslv_poly.h
--------------------------------------------------------------------------------

✗ Changes detected

--- Full Unified Diff ---

--- /home/runner/work/benpy/benpy/src/bensolve-mod/bslv_poly.h	2025-11-05 00:43:36.814382423 +0000
+++ /home/runner/work/benpy/benpy/src/bensolve-2.1.0/bslv_poly.h	2025-11-05 00:43:36.777382297 +0000
@@ -1,7 +1,7 @@
 /*
 This file is part of BENSOLVE - VLP solver
 
-Copyright © 2014-2015 Andreas Löhne and Benjamin Weißing
+Copyright © 2014-2017 Andreas Löhne and Benjamin Weißing
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -21,11 +21,9 @@
 #ifndef BSLV_POLY_H
 #define BSLV_POLY_H
 
-
 #include <limits.h>
 #include <stdio.h>
 
-
 #ifndef ALLOCFCTR
 #define ALLOCFCTR 1
 #endif
@@ -94,7 +92,6 @@
 void poly__primg2file (polytope *, permutation *, const char *, const char *);
 void poly__adj2file (polytope *, permutation *, const char *, const char *);
 void poly__inc2file (polytope *, permutation *, permutation *, const char *, const char *);
-
 void poly__set_default_args (poly_args *args, size_t dim);
 void poly__initialise (poly_args *);
 void poly__kill (poly_args *);
@@ -114,7 +111,7 @@
 void vrtx_cpy (polytope *, size_t,size_t);
 void poly__swap (poly_args *, poly_args *);
 void poly__plot (polytope *, const char *);
-void poly__polyck (poly_args *poly);
+void poly__polyck (poly_args *);
 
 double bslv__normalise (double *, double *, double *, size_t, size_t);
 

--- Analysis by Category ---

VERSION STRINGS:
  bensolve-mod:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
  bensolve-2.1.0:
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

TYPEDEFS:
  bensolve-mod:
    typedef size_t btstrg;
    typedef btstrg vrtx_strg;
    typedef struct poly_list_strct{
    typedef struct polytope_strct{
    typedef struct{
    typedef struct {
  bensolve-2.1.0:
    typedef size_t btstrg;
    typedef btstrg vrtx_strg;
    typedef struct poly_list_strct{
    typedef struct polytope_strct{
    typedef struct{
    typedef struct {

DEFINES (sample):
  bensolve-mod (count: 10):
    #define BSLV_POLY_H
    #define ALLOCFCTR 1
    #define VRTXBLCK (ALLOCFCTR*BTCNT)
    #define LSTBLCK 1
    #define VRTX_VAL(poly,idx) (poly)->data+idx*(poly)->dim
    #define BTCNT (CHAR_BIT*sizeof(btstrg))
    #define ST_BT(lst,idx) (*(lst+idx/BTCNT)|=(btstrg)1<<idx%BTCNT)
    #define UNST_BT(lst,idx) (*(lst+idx/BTCNT)&=~((btstrg)1<<idx%BTCNT))
    #define IS_ELEM(lst,idx) ((btstrg)1U&(*(lst+idx/BTCNT)>>idx%BTCNT))
    #define POLY_EPS 1e-9
  bensolve-2.1.0 (count: 10):
    #define BSLV_POLY_H
    #define ALLOCFCTR 1
    #define VRTXBLCK (ALLOCFCTR*BTCNT)
    #define LSTBLCK 1
    #define VRTX_VAL(poly,idx) (poly)->data+idx*(poly)->dim
    #define BTCNT (CHAR_BIT*sizeof(btstrg))
    #define ST_BT(lst,idx) (*(lst+idx/BTCNT)|=(btstrg)1<<idx%BTCNT)
    #define UNST_BT(lst,idx) (*(lst+idx/BTCNT)&=~((btstrg)1<<idx%BTCNT))
    #define IS_ELEM(lst,idx) ((btstrg)1U&(*(lst+idx/BTCNT)>>idx%BTCNT))
    #define POLY_EPS 1e-9

FUNCTION DECLARATIONS:
  bensolve-mod:
    void poly__initialise_permutation (polytope *, permutation *);
    void poly__kill_permutation (permutation *);
    void poly__vrtx2file (polytope *, permutation *, const char *, const char *);
    void poly__primg2file (polytope *, permutation *, const char *, const char *);
    void poly__adj2file (polytope *, permutation *, const char *, const char *);
    void poly__inc2file (polytope *, permutation *, permutation *, const char *, const char *);
    void poly__set_default_args (poly_args *args, size_t dim);
    void poly__initialise (poly_args *);
    void poly__kill (poly_args *);
    void poly__cut (polytope *, size_t, double *);
    void poly__poly_initialise (polytope *, double *,double *,double *,size_t *);
    int poly__add_vrtx (poly_args *);
    int poly__get_vrtx (poly_args *);
    void poly__poly_init (polytope *);
    void poly__poly_kill (polytope *);
    void poly__list_init (poly_list *);
    void add_vrtx (polytope *);
    int poly__intl_apprx (poly_args *);
    void add_lst_elem (poly_list *, size_t);
    int edge_test (polytope *,size_t,size_t);
    void poly__update_adjacence (polytope *);
    void vrtx_cpy (polytope *, size_t,size_t);
    void poly__swap (poly_args *, poly_args *);
    void poly__plot (polytope *, const char *);
    void poly__polyck (poly_args *poly);
    double bslv__normalise (double *, double *, double *, size_t, size_t);
  bensolve-2.1.0:
    void poly__initialise_permutation (polytope *, permutation *);
    void poly__kill_permutation (permutation *);
    void poly__vrtx2file (polytope *, permutation *, const char *, const char *);
    void poly__primg2file (polytope *, permutation *, const char *, const char *);
    void poly__adj2file (polytope *, permutation *, const char *, const char *);
    void poly__inc2file (polytope *, permutation *, permutation *, const char *, const char *);
    void poly__set_default_args (poly_args *args, size_t dim);
    void poly__initialise (poly_args *);
    void poly__kill (poly_args *);
    void poly__cut (polytope *, size_t, double *);
    void poly__poly_initialise (polytope *, double *,double *,double *,size_t *);
    int poly__add_vrtx (poly_args *);
    int poly__get_vrtx (poly_args *);
    void poly__poly_init (polytope *);
    void poly__poly_kill (polytope *);
    void poly__list_init (poly_list *);
    void add_vrtx (polytope *);
    int poly__intl_apprx (poly_args *);
    void add_lst_elem (poly_list *, size_t);
    int edge_test (polytope *,size_t,size_t);
    void poly__update_adjacence (polytope *);
    void vrtx_cpy (polytope *, size_t,size_t);
    void poly__swap (poly_args *, poly_args *);
    void poly__plot (polytope *, const char *);
    void poly__polyck (poly_args *);
    double bslv__normalise (double *, double *, double *, size_t, size_t);

ENUMS:
  (none found in either version)

STRUCTS:
  bensolve-mod:
    typedef struct poly_list_strct{
    	size_t cnt;
    	size_t blcks;
    	size_t *data;
    } poly_list;
    typedef struct polytope_strct{
    	size_t dim,dim_primg;
    	size_t cnt;
    	size_t blcks;
    	double *ip;
    	double *data;
    	double *data_primg;
    	poly_list *adjacence;
    	poly_list *incidence;
    	vrtx_strg *ideal;
    	vrtx_strg *used;
    	vrtx_strg *sltn;
    	struct polytope_strct *dual;
    	void (*v2h)(double *, int, double *);
    } polytope;
    typedef struct{
    	size_t dim,dim_primg_prml,dim_primg_dl;
    	unsigned int ideal:1;
    	size_t idx;
    	double *val,*val_primg_prml,*val_primg_dl;
    	double eps;
    	polytope primal;
    	polytope dual;
    	void (*primalV2dualH)();
    	void (*dualV2primalH)();
    	struct{double *H,*R,*alph;poly_list queue,gnrtrs;unsigned int intlsd:1;} init_data;
    } poly_args;
    typedef struct {
    	size_t cnt;
    	size_t *data;
    	size_t *inv;
    } permutation;
  bensolve-2.1.0:
    typedef struct poly_list_strct{
    	size_t cnt;
    	size_t blcks;
    	size_t *data;
    } poly_list;
    typedef struct polytope_strct{
    	size_t dim,dim_primg;
    	size_t cnt;
    	size_t blcks;
    	double *ip;
    	double *data;
    	double *data_primg;
    	poly_list *adjacence;
    	poly_list *incidence;
    	vrtx_strg *ideal;
    	vrtx_strg *used;
    	vrtx_strg *sltn;
    	struct polytope_strct *dual;
    	void (*v2h)(double *, int, double *);
    } polytope;
    typedef struct{
    	size_t dim,dim_primg_prml,dim_primg_dl;
    	unsigned int ideal:1;
    	size_t idx;
    	double *val,*val_primg_prml,*val_primg_dl;
    	double eps;
    	polytope primal;
    	polytope dual;
    	void (*primalV2dualH)();
    	void (*dualV2primalH)();
    	struct{double *H,*R,*alph;poly_list queue,gnrtrs;unsigned int intlsd:1;} init_data;
    } poly_args;
    typedef struct {
    	size_t cnt;
    	size_t *data;
    	size_t *inv;
    } permutation;


==================================================================================
Recommendations
==================================================================================

Based on this diff, the following updates may be needed:

1. Update version strings in wrapper code (if any reference THISVERSION)
2. Review and update Cython .pxd files with new function signatures
3. Check for any new/removed/modified enum values
4. Verify struct definitions match in Cython declarations
5. Update any #define constants that changed
6. Test compilation with updated declarations

Next steps:
  - Review this report carefully
  - Create .pxd files for Cython declarations
  - Update benpy.pyx to use new declarations
  - Run test builds to identify issues


==================================================================================
End of Report
==================================================================================

